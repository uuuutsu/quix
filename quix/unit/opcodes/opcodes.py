from .base import opcode
from .dtypes import Anchor, IOValue, Literal, Unit, UnitProgram, Value, Wide, WideLiteral

# base


@opcode
def move(from_: Wide, to: list[tuple[Unit, Value]]) -> None: ...
@opcode
def copy(from_: Wide, to: Wide) -> None: ...
@opcode
def assign(from_: Wide, to: WideLiteral) -> None: ...
@opcode
def clear(value: Wide) -> None: ...


# array


@opcode
def arr_store(anchor: Anchor, offset: WideLiteral, value: WideLiteral) -> None: ...
@opcode
def arr_load(anchor: Anchor, offset: WideLiteral, target: Wide) -> None: ...
@opcode
def arr_move(anchor: Anchor, from_offset: WideLiteral, to_offset: WideLiteral) -> None: ...


# arithmetic


@opcode
def add(left: WideLiteral, right: WideLiteral, target: Wide) -> None: ...
@opcode
def sub(left: WideLiteral, right: WideLiteral, target: Wide) -> None: ...
@opcode
def mul(left: WideLiteral, right: WideLiteral, target: Wide) -> None: ...
@opcode
def divmod(left: WideLiteral, right: WideLiteral, remainder: Wide, quotient: Wide) -> None: ...
@opcode
def pow(left: WideLiteral, right: WideLiteral, target: Wide) -> None: ...


# binary


@opcode
def and_(left: Literal, right: Literal, target: Unit) -> None: ...
@opcode
def or_(left: Literal, right: Literal, target: Unit) -> None: ...
@opcode
def xor(left: Literal, right: Literal, target: Unit) -> None: ...
@opcode
def not_(left: Literal, target: Unit) -> None: ...


# conditions


@opcode
def call_z(left: Unit, if_: UnitProgram, else_: UnitProgram) -> None: ...
@opcode
def call_eq(left: Unit, if_: UnitProgram, else_: UnitProgram) -> None: ...
@opcode
def call_ge(left: Unit, if_: UnitProgram, else_: UnitProgram) -> None: ...
@opcode
def call_gt(left: Unit, if_: UnitProgram, else_: UnitProgram) -> None: ...
@opcode
def call_le(left: Unit, if_: UnitProgram, else_: UnitProgram) -> None: ...
@opcode
def call_lt(left: Unit, if_: UnitProgram, else_: UnitProgram) -> None: ...


# I/O


@opcode
def input(left: IOValue) -> None: ...
@opcode
def output(left: IOValue) -> None: ...
